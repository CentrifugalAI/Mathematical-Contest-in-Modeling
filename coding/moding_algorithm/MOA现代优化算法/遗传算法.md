# 启发式算法系列开篇

这是介绍启发式算法家族的第一篇文章。

启发式算法指的是：

启发式算法主要区别于传统优化算法，后者通过目标函数的梯度达到目标函数结果最优化，它是一种确定性的搜索方式。

而启发式算法的特点就在于随机搜索并且通过这一特性获取更高的全局最优可能性。由于和函数梯度的利用无关，所以启发式算法并不要求目标函数具有连续可微的条件，为一些无法通过梯度下降优化的目标函数提供了优化的可能性。

人类通过观察自然的演变和动物的行为，将它们用于真实场景的模拟当中，这些就是启发式算法的灵感来源，因此这些算法听上去也比一般的算法更加有趣，无论是初入算法世界的萌新，还是准备数模竞赛的同学，都能在启发式算法的家族里窥探到算法学家的智慧和有趣。

本文同接下来一个系列的几篇文章都将介绍启发式算法的原理、具体过程到最后的代码实现，代码实现上，会提供尽量 `MATLAB` 和 `python` 两种代码框架。

欢迎关注 & 追更！！！

# 遗传算法基础

## 遗传算法简介

遗传算法（Genetic Algorithm，简称 GA ），顾名思义，这是一种模拟自然选择生物进化和个体繁衍时交叉、复制、变异等现象的算法。

遗传算法的过程就模拟了一个物种的进化史诗，而其结果旨在于通过残酷的优胜劣汰机制留下我们规定的世界中的最优解——哪个种群越接近最优解，才能挺过无数场竞争，让基因得以保留。

## 遗传算法术语和概念

### 染色体、位串、基因

位串在算法中就相当于生物学上的染色体的概念。

而基因则可以看作染色体的组成单元，染色体上的所有基因共同作用，最终决定了一个个体的性状。

比如，在很多情况下，我们会将基因建模成一个个二进制位，则染色体就是一个二进制串。

举一个非常简单的例子，我们希望确定一组参数 $w_1,w_2,\cdots,w_n$ ，能够使目标问题得到最优解。

就取 $w_1,w_2,\cdots,w_n$ 的二进制数，将它们拼接成一个 $01$ 串，这个串上的每个 $0$ 或者 $1$，都是一个基因

而这组参数的取值就可以称之为一个染色体，比如我们认为 $w_1,w_2,\cdots,w_n$ 都是一个八位二进制数，它们就能表示为：

$$
\underbrace{10111010101010111\cdots0101001001001111\cdots010100111100101}_{共 8\times n位}
$$

### 特征值

在用串表示整数时，基因的特征值与二进制数的权一致——比如染色体 $10001$ 中第一个 $1$ 表示的基因的特征值为 $16$

### 基因型和表现型

基因型在遗传算法中指的就是问题可行解的一种编码，比如上面举的那个例子中，$10111010101010111\cdots0101001001001111\cdots010100111100101$ 就是一个基因型，它经过解码后还原得到的一组参数 $w_1,w_2,\cdots w_n$ 在实际问题中的表现状态就是一组可行解的表现型。

> 事实上，一组可行解就是一个个体

### 适应度

这是遗传算法中最重要的概念之一（**敲黑板**），因为——

它决定了我们规定的进化方向，是这个优胜劣汰的世界中的基本规则

适应度的本质就是一个函数，根据上面的例子，这个函数可能就像下面这样：

$$
X = t(w_1,w_2,\cdots,w_n)
$$
$$
S = f(X)
$$

这两行公式的意思是，函数 $t(w_1,w_2,\cdots,w_n)$ 表示一个生物个体的基因在目标函数下的表现性状。

> 目标函数指的就是我们希望优化的对象
> 
> 在自然界中，这个目标函数就是尽量地活下去
> 
> 在我们的遗传算法空间中，这个目标函数就由我们自己定义：它可以指旅行商问题中的路径，可以指加工一批硬件的时间......

生物的表现性状 $X$ 由它的一系列基因 $w_1,w_2\cdots,w_n$ 决定，$f(X)$ 就是适应度函数，适应度函数旨在于评估生物性状，给出哪些生物更适合活下来的依据。

对应到算法中，适应度函数就是我们优化的对象，比如让旅行商的行走总路径，那么遍历每个城市的任何一种方案都可以视为具有各自染色体的个体，我们的适应度设计目的就是为了寻找最优、最符合问题答案的个体的染色体，它就是我们问题的解。


### 算子

算子的英文原名就是 $operator$，其实就是操作，算子的种类有：

- 选择算子（Selection Operator）
- 交叉算子（Crossover Operator）
- 变异算子（Mutation Operator）

这三个算子的涵义和作用会在后面具体过程中进行讲解，注意：这只是基本遗传算法的算子，更复杂的遗传算法会包含更多种类的算子。

# 遗传算法的步骤

## （一）染色体编码

我们刚刚已经提到过，遗传算法的可行解可以表示成基因的形式，基因也可以被还原为可行解的形式。前者被称为编码，后者则称为解码。

> 比如 $\underbrace{10111010101010111\cdots0101001001001111\cdots010100111100101}_{共 8\times n位}$ 就是基因，$w_1,w_2,\cdots w_n$ 就是一组可行解（性状）

一般而言，染色体编码要遵循下面这些准则：

-  完备性（Completeness）：问题空间中的所有候选解都能编码为 GA 空间中的染色体

-  非冗余性（Nonredundancy）：染色体和候选解一一对应

下面提供三种染色体编码的技巧和思路：

### 二进制编码方法

就是将一组问题的可行解全部转换为二进制数的形式，并对这些二进制数进行拼接得到一个 $01$ 串，这个 $01$ 串就是染色体

> 注意：小数和整数都可以编码成二进制数。对于小数而言，还应该在编码时确定小数点的位置
> 
> 编码方案应该和数据范围以及数据变化灵敏度相适应，如下：

$000000\cdots00000 = 0\delta$ 对应范围的下界

$111111\cdots11111 = (2^n-1)\delta$ 对应范围的上界

而 $000000\cdots00001$ 表示数据的灵敏度 $\delta$

### 格雷编码

格雷码（Grey Code）也被称之为反射二进制码，是一个二进制数系，其中两个相邻数的二进制位只有一位不同，并且最大数与最小数之间也仅一位数不同。

二进制码和格雷码在使用时的一点明显区别就是：

比如当一个染色体的取值需要增加一个单位量时（$\sigma$），如果原染色体是 $1000001111111$ ，转换后得到的就是 $100001000000$ ，一共需要修改 $7$ 个基因，而如果使用格雷码进行编码，“相邻染色体”之间的差别就是一个基因，大大降低了相邻值之间的转换时间，能够使算法的局部搜索能力增强。

格雷码和二进制码的相互转换可以使用下面的思路进行转换：

设某二进制格雷码为 $G_{n-1}G_{n-2}\cdots G_2G_1G_0$，自然二进制码为 $B_{n-1}B_{n-2}\cdots B_2B_1B_0$

二进制码转格雷码：

- 最高位保留：$G_{n-1} = B_{n-1}$
- 其它各位进行异或操作：$G_i = B_{i+1}\oplus B_i$
  
格雷码转二进制码：

- 最高位保留：$B_{n-1}=G_{n-1}$
- 其它各位进行异或运算：$B_{i-1}=G_{i-1}\oplus B_i$

> 由于格雷码拥有二进制编码的优点，并且其特性更提供了一些额外的优势，因此建议在使用二进制时，总是用格雷码进行替代

```python

```

返回结果为：
```

```


### 浮点数编码方法

将一组问题的可行解全部转换为浮点数的形式，浮点数的设计可以参照 $IEEE$ 标准自行完成，目的是为了增大可行解的表示范围，又不至于让染色体变得过长

> 一些精度要求较高的问题，如果使用二进制编码直接表示，往往会使得染色体的长度变得过长，不利于我们求解
>
> 使用浮点数进行编码不是为了能够表示小数（这点二进制编码也能够做到），而是为了能够利用阶码表示更大的数

### 符号编码方法

使用自定义的符号进行编码的方法，其中自定义的符号是指无数值含义、而只有代码含义的符号集，比如 $\{solution_1,solution_2,\cdots,solution_n\}$

应该注意的是，使用符号编码后，还要考虑后续的变异、交叉等算子应该怎样对染色体上的基因进行操作，这些操作是否符合约束条件。

### 实数编码方法

遗传算法可以使用二进制串来表示整数和实数，但是使用二进制串表示的实数的精度受串长度（位数）的限制。由于需要提前确定该长度，因此最终可能由于二进制串太短导致精度不足或编码过长。

因此除了使用浮点表示方法外，使用实数值数组代替二进制串也是一种简单可行的方法。

比如将染色体设计为 $x_1x_2x_3$ ，其中 $x_1 = 1.57,x_2 = 2.89,x_3 = 3.68$ ，这就是一个实数编码的染色体。

> 本文指的实数编码方法和浮点数编码方法是有区别的，前者指每个变量就是一个基因，用原始的实数数据进行编码，后者指用类似于 `IEEE754` 的格式先将浮点数转换成二进制数，再用来进行编码。

## （二）生成初始种群

遗传算法的操作对象是一个群体，因此现需要准备一些表示起始搜索点的初始群体数据。对于启发式算法而言，更好的起始数据更有利于算法的搜索表现。

原则上，在不确定解的大致情况时，我们希望初始种群的群体尽量大，减少解得到的偶然性；基因尽量分散，使解的来源尽量广泛。

## （三）进行选择运算

选择运算也是遗传算法中的一种算子（Operator），选择操作从旧群体中以一定概率选择优良个体组成新的种群，以繁殖得到下一代个体。

这时就应该提到开始时定义的“适应度”，在自然界，适应度反映的是一个生物群体能否适应环境并在残酷竞争中存活下来；在遗传算法中，适应度反映的是一个解（染色体/个体）是否在我们的目标函数中表现得更优，比如上面规定的：路程是否更短，时间开销是否更小.......

适应度的大小应该和一个解的优质程度成正相关，假设一个种群的数量为 $M$，个体 $i$ 的适应度为 $f_i$ ，则个体被选取的概率为 

$$
P_i = \frac{f_i}{\sum_{k=1}^Mf_k} \qquad i = 1,2,\cdots,n
$$

如下几种方法可以用来充当选择算子：

### 俄罗斯轮盘赌

一般而言，选择算子使用俄罗斯轮盘赌算法（Russian roulette），它的起源就是左轮手枪对赌自杀游戏

> 不错，这很战斗民族......
> 
> <center><img src = https://s1.ax1x.com/2022/09/03/voVRWq.png width = 45%></center>

俄罗斯轮盘赌算法的操作过程如下：

- 计算所有个体的适应度总和 $F = f_0 + f_1 + \cdots + f_n$
- 在 $[0,F]$ 之间生成一个随机数，并根据 $f_0,f_1,\cdots,f_n$ 的大小将 区间 $[0,F]$ 分成 $n$ 个“弹膛”
- 这个随机数落入哪个“弹膛”，就选择哪个“弹膛”对应的个体

> 一个个体的适应度越大，那么它对应的弹膛也就越大，被选中的概率就越高
>
> 由于这是一个基于随机数的算法，因此可能会出现适应度很高的个体却无法遗传至下一代的情况，这并不完全是缺点，因为它也保证了后代种群的演化多样性——最强大的个体不一定能活下来，大自然的戏剧性不也如此吗？

### 锦标赛选择

所有个体被随机选择，开展若干轮竞赛（两两竞赛/多个体竞赛），其中适应度最高的获胜并被选中。

> 每轮锦标赛参与的个体数量称为锦标赛规模，而锦标赛的轮数一般由个体总数和锦标规模决定

如果个体数量（$n$ 个）过多，保证个体进行两两竞赛是比较困难的（开展 $C_n^2$ 轮），此时可以先对个体进行分组淘汰

> 对于符号编码的情况，可能需要考虑采用自行设计的选择算子

## （四）进行配对和交叉操作

和生物学中的过程一样，进行交叉之前还应该先进行染色体的配对环节（也就是个体的配对），配对指的时从种群中随机选择两个个体进行组合，类似于自然界中的交配现象。

交叉操作则指对已经配对的两条染色体中的基因进行交换，有如下几种交叉算子支持这一操作的实现：

> 以下是基于二进制编码（格雷码、浮点数编码）的交叉操作

### 单点交叉（Single-point Crossover）

在两条配对的染色体中随机设置一个位置交叉点，在该交叉位置对两条配对的染色体进行进行分割并交换位置交叉点右侧的染色体片段。

<center><img src = https://s1.ax1x.com/2022/09/03/voV6oj.png width = 40%> &nbsp;&nbsp;&nbsp;<img src = https://s1.ax1x.com/2022/09/03/voVseg.png width = 41%></center>

> 单点交叉混合的速度较慢（因为将染色体分成两段进行交叉，这种方式交叉粒度较大），但对于选取交叉点位置具有一定内在含义的问题而言，单点交叉可以造成更小的破坏。

### 两点交叉（Two-points Crossover）

两点交叉是指在个体染色体中随机设置了两个交叉点，然后再将两个交叉点之间的染色体片段进行交换。

<center><img src = https://s1.ax1x.com/2022/09/03/voVgFs.png width = 40%> &nbsp;&nbsp;&nbsp;<img src = https://s1.ax1x.com/2022/09/03/voVywQ.png width = 39.5%></center>

### 多点交叉（Multi-point Crossover）

多点交叉或称广义交叉，是指在个体染色体中随机设置多个交叉点，然后在这些点的位置进行单个基因的交换。

<center><img src = https://s1.ax1x.com/2022/09/03/voV2Yn.png width = 40%> &nbsp;&nbsp;&nbsp;<img src = https://s1.ax1x.com/2022/09/03/voVfS0.png width = 38.6%></center>

### 均匀交叉（Uniform Crossover）

均匀交叉也称一致交叉，这个交叉算子遍历两个染色体的全部基因位点，每个基因位点都有相同的交叉概率发生在两个染色体间的交叉互换，效果如下：

<center><img src = https://s1.ax1x.com/2022/09/03/voVhlV.png width = 45%></center>

> 以下是实数编码的交叉操作

### 算术交叉

算术交叉算子是一种适用于实数编码的交叉操作，它将父母两个个体的染色体进行线性组合，进而产生的新的个体。

$$ 
X_A^{t+1} = \alpha X_B^{t} + (1-\alpha)X_A^{t}
$$

$$
X_B^{t+1} = \alpha X_A^t + (\alpha-1)X_B^t
$$

上式中的 $\alpha$ 是一个参数，它可以是常数或者进化代数决定的变量，如果是后者的情况，此时的交叉变换就称为非均匀交叉变换。

### 混合交叉（blend crossover）

混合交叉算子是一种适用于实数编码的交叉操作，在混合交叉中，每个后代都是从其亲代创建的以下区间中**随机**选择的：

$$
X^{t+1}\in [X^t_1-\alpha (X^t_2 - X^t_1),\;X_2^t+\alpha(X_2^t - X_1^t)
$$

> 该式假设 $X_2^t > X_1^t$ ，实际情况灵活处理

$\alpha$ 是一个预确定的参数，其值在 $0$ 到 $1$ 之间，$\alpha$ 越大，区间就越大。

> $\alpha=0$ 时，选取范围就在两个亲代之间。

### 模拟二进制交叉（Simulated Binary Crossover）

模拟二进制交叉算子是一种适用于实数编码的交叉操作，在模拟二进制交叉中，每个后代都是由亲代染色体创建的以下等式决定的：

$$
X_1^{t+1} = \frac{1}{2}(1+\beta)X_1^t+\frac{1}{2}(1-\beta)X_2^t
$$

$$
X_2^{t+1} = \frac{1}{2}(1-\beta)X_1^t+\frac{1}{2}(1+\beta)X_2^t
$$

模拟二进制交叉算子的特性是：

- 不管 $\beta$ 的值如何，两个后代的平均值等于两个亲代的平均值
- 当 $\beta$ 的值为 $1$ 时，后代是双亲的副本
- 当 $\beta$ 值小于 1 时，后代间的距离比亲代间的距离更短
- 当 $\beta$ 值大于 1 时，后代间的距离比双亲间的距离更远

<center><img src = https://s1.ax1x.com/2022/09/03/voV7TJ.png width = 45%></center>

> 对于符号编码的情况，可能需要考虑采用自行设计的交叉算子

> 更多交叉方法可以参见 https://blog.csdn.net/u010743448/article/details/108445588 ，这里不作完全枚举

## （五）变异

为了防止遗传算法在优化过程中陷入局部最优解，在搜索过程中，需要对个体进行变异操作，并以此更准确地模拟自然选择的过程。

变异是产生新的基因和个体的重要方式，往往能在遗传算法中起到随机搜索避免陷入局部最优的效果。但是如果变异概率过高，会导致变异过于频繁而丢失优秀的个体。

> 下面是适用于基于二进制的编码（包括格雷码、浮点数编码）的变异算子

### 位翻转突变（Flip Bit Mutation）

适用于以二进制为基础的编码方式，比如自然二进制编码法、格雷编码法和浮点数编码法。

算法流程非常简单：在随机选择若干个基因，将其值进行翻转（$01$互换 ）

<center><img src = https://s1.ax1x.com/2022/09/03/voV4yT.png width = 66%></center>

### 交换突变（Swap Mutation）

随机选择若干对个基因并交换一对基因中的两个值

<center><img src = https://s1.ax1x.com/2022/09/03/voV5OU.png width = 66%></center>

这个突变算子适用于有序列表的染色体，因为新染色体仍带有与原始染色体相同的基因，如果是无序染色体，交换突变将会失效。

### 反转突变（Inversion Mutation）

选择一段随机的染色体片段（基因序列），将该序列中的基因顺序颠倒

<center><img src = https://s1.ax1x.com/2022/09/03/voVomF.png width = 66%></center>

同样，这个突变算子仅适用于有序列表的染色体。

> 下面是适用于基于实数编码方法的变异算子

### 高斯变异

高斯变异算子通过用一个均值 $\mu$ 、方差为 $\sigma$ 的正态分布的一个随机数来替换原有基因值 $u$。

高斯变异的局部搜索能力较好，但是引导个体跳出局部较优解的能力较弱，不利于全局收敛。

### 步长变异

步长变异算子通过给变异基因加上或减去一个称为步长的值来实现变异的效果，即：

$$
X^{t+1} = X^{t} + Ld 
$$

> 对于符号编码的情况，可能需要考虑采用自行设计的变异算子

## 检查退出条件

通过检查经过选择、遗传、交叉和变异这些过程后得到的新种群是否满足预设的判断条件。如果满足，退出循环迭代体系；如果不满足，则将当前的种群加入下一轮循环迭代

至此，一个遗传算法的完整流程可以被总结如下——

一个基本的遗传算法至少需要确定四个运行参数：

- 种群大小 $M$
- 遗传算法的终止进化代数 $T$
    > 用于设置预定义的遗传算法结束条件
- 交叉概率 $PC$
- 变异概率 $PM$

整合上面的各个过程，一个基本的遗传算法框架如下：

<center><img src = https://s1.ax1x.com/2022/09/03/voVTw4.png width = 50%></center>

# 杂项

## 代码框架详见下篇：遗传算法的代码构建

## 其它补充

遗传算法发展至今已经加入了很多全新并且深刻的内容，比如变异方法、选择方法、交叉方法的改进版本，如柯西变异、混沌变异这样的新名词不断浮现。

本文旨在于给出一个最基本的遗传算法框架，实际情况使用的模型往往是需要不断修正、补充和丰富的。

# **<center>参考文献：</center>**
 
> 格雷码和俄罗斯轮盘赌算法的简介部分：http://accu.cc/content/ga/russian_roulette/
> 
> 遗传算法简介部分：https://zhuanlan.zhihu.com/p/100337680
>
> 遗传算法交叉算子部分：https://blog.csdn.net/u010743448/article/details/108445588 & https://benpaodewoniu.github.io/2018/10/27/es4/ & https://zhuanlan.zhihu.com/p/435885104
>
> 遗传算法变异算子部分：https://zhuanlan.zhihu.com/p/435885104









