# LINGO 入门指南

## 为什么是 LINGO

`LINGO` 是一款专门用于解决规划类问题的软件。在处理线性规划问题上，和 `MATLAB` 相比，`LINGO` 更具有优势：

- 可以支持二维决策变量
- 求解 `NLP` 问题时不需要进行初值估计
- 使用集合命令，更加直观，方便描述复杂条件
- 不需要人为指定算法，减少了理解算法的过程

对于 `LINGO` 软件的使用，可以分为以下两种方法——

- 直接描述法：用数学语言直接描述出线性规划模型的约束条件、决策变量和目标函数
- 建模描述法：通过用 `LINGO` 编程语言描述线性规划模型的变量和条件，实现模型的求解


## LINGO 直接描述法

直接描述法几乎没有难度——就是把数学问题几乎原样地在 `LINGO` 编程区描述一下，比如下面的代码就能直接在 `LINGO` 上运行，即使不需要注释也能很轻松地看懂.

```lingo
max = 4 * x + 3 * y;
2 * x + 3 * y <= 10;
x >= 1;
```

> 在默认情况下，`LINGO` 会指定决策变量的取值都是大于 $0$ 的，解除这个限制需要使用 `@free` 函数
> 
> 和 `MATLAB` 不同，`LINGO` 可以通过关键字 `max` 或 `min` 来指定目标函数是取最大/最小值
> 
> 如果不指明关键字 `max` 或 `min` 比如将第一行代码修改为：
>
>```
>a = 4 * x + 3 * y;
>```
>
> 返回的提示就不再是 `Global optimal solution found.` ，而是 ` Feasible solution found` ，表示找到可行解。

运行结果如下，`LINGO` 会返回一个窗口，然后再窗口中详细描述本次规划问题解决的信息

<center><img src = images/1.png width = 70%></center>

> 一般而言，简单的线性规划模型我们都会采用 `LINGO` 的直接描述法而不必进行建模描述

## LINGO 数据组织

### LINGO 数据类型——集

`LINGO` 的集定义为：一群相联系的对象。事实上，“集”就是一个由对象组成的群体。

`LINGO` 的集分为两种类型——

- 原始集：只由对象组成
- 派生集：可以由原始集组成，也可以包含其它派生集

集合的定义：

我们直接从一个现实实例来具体说明如何定义 `LINGO` 集合类型：

`LINGO` 中的所有集合变量必须定义在一个框架中：框架的开头是 `sets:` ，框架的末尾是 `endsets` ，如下：

```lingo
sets:
    !这是一个可以跨越多行的注释（用 '!' 开头，用 ';' 结尾）
    set1
    set2
    ......
    set3
    ;
endsets
```

假设我们要将一个学生群体定义成 `LINGO` 集合数据的形式。

我们可以单纯地只定义一个学生群体的集合：

```lingo
student;
```

我们也可以为这个学生集合添加属性变量：

```lingo
student: name, age; 
```

这行代码的语法表示：我们定义学生群体，这个对象有性别和年龄两个属性变量

而当我们要阐释一个群体中所有成员时，则可以采用下面的语法（显示罗列法）逐个罗列出对象：

```lingo
student/stu1, stu2, stu3/: name, age;
```

这行代码表示学生集合中有三个对象：他们分别是`stu1`，`stu2` 和 `stu3`

而当我们要定义更多的集合对象时，很明显我们不能一个一个的输入对象们的名字——当数据量一大，这实在是不小的工程量。幸运的是 `LINGO` 提供了隐式罗列法：这也是 `LINGO` 的特别之处，它定义了 `..` 运算符，这个运算符可以智能地根据规律来填充我们没有完全写出的集合对象名，我们可以像下面这样使用它——

```lingo
student/stu1..stu100/: name, age;
```

这行代码表示学生集合中一共有 $100$ 个学生对象，它们的对象名分别是 `stu1` ，`stu2`，$\cdots$ ，`stu100`

> `LINGO` 大小写不敏感——这意味着 `STU1` 和 `stu1` 代表完全相同的涵义
>
> `LINGO` 规定在集合数据类型的定义中只有集合名字是必须声明的，而集合的成员列表和属性变量列表都是可以省略的

另外我们还可以通过已有的集合来定义新的集合，这就是派生集的定义。

考虑工厂加工问题的求解：我们需要定义不同工人操作不同机器，他们加工不同产品，那么可行方案就应该是：哪个工人 + 操作哪台机器 + 生产哪个产品，定义方法如下：

```lingo
sets:
! 原始集;
worker:/worker1..worker3/: efficiency;    ! 工人效率;
machine:/machine1..machine3/: quality;    ! 机器质量;
product:/product1..product3/: value, cost; ! 产品价值和消耗;

! 派生集;
allowed_plan(worker, machine, product): evaluation;    ! 对可行方案的评价;
endsets
```

像上面这样，派生集的所有对象实际上就是原始集的所有对象的组合，即 $(workeri,machinej, productk)\; ,i\in(1,3),\; j\in(1,3),\; k\in(1,3)$ ，这种派生集就称为**稠密集**

相反，如果原始集的所有对象的组合并不包含在派生集中，那么这种派生就被称之为**稀疏集**

此外，我们经常看到 `links` 相关的语法，事实上它们的本质也是派生集，只是 `links` 显示地指出这些集是派生出来

> 也有人用“矩阵工厂”的概念来描述集合，我赞同他们的观点

### LINGO 集合初始化

在定义了“集合”这种数据类型之后，我们就可以对这些集合数据类型进行初始化赋值

`LINGO` 的集合初始化也是需要定义在一定的框架内，这个框架的形式如下所示：


```lingo
data:
   !将数据定义在这里面;
enddata
```

我们对集合数据类型进行初始化赋值，本质上是对属于集合的所有成员对象的属性变量进行赋值，还是通过上面那个工人借助机器生产产品的例子，我们对这个例子中的数据进行赋值——

#### 对集合对象的所有属性变量进行初始化

```lingo
data:
efficiency = 4 3 2
quality = 3 2 1
value = 50 20 10
enddata
```

像上面这样，我们可以通过每行对一个变量进行赋值，Lingo语言会帮我们将这些空格隔开的数字按照顺序相应的赋值给集合的成员对象

比如 `efficiency` 那一行中 `=` 后的 $3$ 个数字分别意味着 `worker1` 的效率是 $4$ ，`worker2` 的效率是 $3$ ，`worker3` 的效率是 $2$ ，剩下两行的内容同理可得

当然对于那些对象个数一样的属性变量我们可以将它们放在一行中一起赋值，这个时候数据的组织顺序有所不同，比如我们可以将上面 $3$ 个属性变量（因为它们的对象个数都是 $3$ 个）放在一行中，然后将要输入的数据组织成矩阵进行赋值

```lingo
data:
efficiency, quality, value = 4 3 50
                             3 2 20
                             2 1 10;
enddata
```

> `LINGO` 通过换行隔离开不同个数据

在上面这个 $3\times3$ 的矩阵中，第一列代表了工人的效率，第二列代表机器的品质，第三列则代表产品的价值

这样我们的数据类型描述就算完成了。当然你可能会疑问：那些只能被规定为整数变量的数据类型应该怎么描述呢？这就涉及到 `LINGO` 函数的使用，紧接着将会解释这一部分内容。

#### 其他特殊的数据初始化方式

- 在所有集合对象中将一个属性变量初始化为同一个值

比如我们设置所有工人的效率一样，都为 $3$

```lingo
efficiency = 3;
```

- 实时数据处理
  
比如我们设置 `worker2` 的效率为非定值，只要在本该放书的地方输入一个 `?` 即可

```
efficiency = 2 ? 4;
```

- 未知数值处理
  
我们希望在程序模型中将一个属性变量在部分成员对象中设置为未知，以便让 `LINGO` 求出它们的最优解

在属性变量的某些值为未知的时候，我们不能再用空格隔开不同的值，而应该用逗号来取代，如下

```
efficiency = 2, , ;
```

这里表示 `worker2` 和 `worker3` 的 `efficiency` 都是未知的




## LINGO 运算符

### 逻辑运算符

当我们需要使用 `LINGO` 来描述一个线性规划问题时，很自然的就需要使用逻辑运算符来描述问题应该满足的条件

`LINGO` 提供了 $9$ 种逻辑运算符，如下表所示：

| 运算符名称 | 运算符涵义                                                     |
| ---------- | -------------------------------------------------------------- |
| #not#      | 一元运算符，否定该操作数的逻辑值                               |
| #eq#       | 若两个运算数相等，则为 true ，否则为 false                     |
| #gt#       | 若左边的运算符严格大于右边的运算符，则为 true ，否则为 false   |
| #ge#       | 若左边的运算符大于或等于右边的运算符，则为 true ，否则为 false |
| #lt#       | 若左边的运算符严格小于右边的运算符，则为 true ，否则为 false   |
| #le#       | 若左边的运算符小于或等于右边的运算符，则为true，否则为false    |
| #and#      | 仅当两个参数都为true时，结果为true，否则为false                |
| #or#       | 仅当两个参数都为false时，结果为false，否则为true               |

### 算术运算符和关系运算符

`LINGO` 提供了 $5$ 种二元运算符，优先级和我们平常认知的相同

即 `^`、`*`、`/`、`+` 和 `-` 。

一元运算符只有取反：`-`

`LINGO` 关系运算符主要用于描述约束条件，它们和逻辑运算符并不相同，不存在真假，只要是被关系运算符所描述的，就是在我们的模型中所有决策变量必须遵守的条件。

提供了 $3$ 种关系运算符，即 `=`、`<=` 和 `>=` 。但 `LINGO` 并不支持严格小于和严格大于的关系算符，不过我们可以通过修改小于等于式来实现这种关系：

如 $a>b$ 可以修改为 $a+\epsilon>=b$，$\epsilon$ 是一个很小的正数，它的取值取决于于我们模型中所需要的精度。

### 使用示例

## LINGO函数

`LINGO` 的函数特点是：每个函数都在开头位置有一个 `@` 符表示这是一个函数。

`LINGO` 的函数有如下几种分类——

### 变量界定函数

变量界定函数实现对决策变量取值范围的附加限制：

- `@bin(x)` 限制 $x$ 为 $0$ 或 $1$
- `@bnd(L, x, U)` 限制 $L\le x\le U$
- `@free(x)` 取消对变量 $x$ 的默认下界为 $0$ 的限制，即 $x$ 可以取任意实数
- `@gin(x)` 限制 $x$ 为整数
  
> 在默认情况下，`LINGO` 规定变量是非负的，也就是说下界为 $0$，上界为 $+\infin$。`@free` 取消了默认的下界为 $0$ 的限制，使变量也可以取负值。`@bnd` 用于设定一个变量的上下界,它也可
以取消默认下界为 $0$ 的约束。

### 集循环函数

集循环函数通过遍历属性变量所在的整个集的所有对象来进行操作：

集循环函数的语法是：`@for(集合名(i): [对属性名(i)的相关操作])`

上面的语法看起来很抽象我们还是通过上面的例子来解释一下这个语法——

假设我们希望对工人的效率进行赋值，使得工人的效率满足：$工人的效率 = 工人的索引 \times 2 + 1$，可以使用下面的语句：

```lingo
    @for(worker(i): efficiency(i) = 2 * i + 1);
```

如果我们只想操作 `worker1` 和 `worker2` 也可以通过 `|` 后添加范围的语法调用：

> 操作范围是一个逻辑表达式，当这个逻辑表达式为真时就会对 `:` 后面的相应索引的属性变量进行相应操作。

```lingo
@for(worker(i) | i #le# 2 : efficiency(i) = 2 * i + 1);
```

`@sum` 函数、 `@min` 函数、 `@max` 函数和 `prog`函数（求积）的语法都非常类似，它们也可以添加函数操作范围，并用竖线 `|` 分隔属性名和操作范围。

如下的代码用来计算 $3$ 个工人的效率总和以及前 $2$ 个工人的效率最大值和最小值。

```lingo
efficiency_sum = @sum(worker(i) | i #le# 3 : efficiency);
efficiency_min = @min(worker(i) | i #le# 2 : efficiency);
efficiency_max = @max(worker(i) | i #le# 2 : efficiency);
```

我们详细解释一下第二行代码的意思吧：他表示对 `worker` 中的 `efficiency` 属性求解最小值并且索引 `i` 小于等于 $2$，这意味着他在进行这个函数的时候只会考虑前 $2$ 个对象的 `efficiency` 属性

当然我们也可以不指定范围这样就默认对集合中所有成员对象的某个属性变量进行操作：

```lingo
efficiency_sum = @sum(worker : efficiency);
efficiency_min = @min(worker : efficiency);
efficiency_max = @max(worker : efficiency);
```

上面三行代码表示求解所有工人效率的总和、最小值和最大值。

> 这些集循环函数的调用其实都很相似，只是 `@for` 函数需要指定操作方式，其它四种只需要指定操作的属性，仅此而已
> 
> 可以统一成这种格式：`@函数名(集合名(索引) | 范围界定（可选） : 要操作的属性变量或要进行的操作)`
> 
> 很经常地，这些集合操作函数不只是对集合进行操作，往往还用来描述目标函数和约束条件，可以到最后的例题中体会实际使用的方法
> 
> 可以让要操作的属性可以不属于集合名，而只是把集合名当作提供索引的“工具人”，如后面例题中的 $TSP$ 问题描述每行/每列之和为 $1$ 时的处理

### 数学函数

数学函数是 `LINGO` 语言中几乎最重要的函数。因为我们刚刚说过 `LINGO` 只支持 $5$ 种最基本的运算符号，而要实现复杂的函数就必须调用数学函数。

数学函数都是顾名思义就能理解，可以参见下面这张表格：

<center><img src = images/3.png width = 40%></center>

### 逻辑判断函数

`@if` 函数是一个逻辑判断函数，通常仅仅在分段函数处出现，一般其出现频率、使用次数不高。

函数调用形式如下：

```
@if(条件描述, 满足条件的返回值, 不满足条件的返回值)
```

比如我们希望定义一个分段函数，在小于等于零时返回 $0$ ，在大于零时返回原值，就可以用：

```
@if(x #le# 0, 0, x);
```

我们还可以为逻辑判断函数设置嵌套，比如我们希望在小于等于 $-2$ 时返回 $x^2$ 而不是 $0$，就可以：

```
@if(x #le# 0, @if(x #le# -2, x^2, 0), x);
```

这行代码在满足条件的返回值处内嵌了一个 `@if` 函数

### 其它函数

#### 输入输出函数

一些输入输出函数可以用来帮助我们节约从文件转移数据的时间。

- `@file('filename');` ： 从外部文件输入数据
- `@text('filename');` ： 将指定内容输出到文本文件中
- `@ole('filename')` ： 从 `EXCEL` 中引入或输出数据
- `@warn('text', logical_condition)` ： 如果逻辑条件 `logical_condition` 为真，则产生一个内容为`'text'` 的信息框。

#### 返回信息函数

一些函数返回信息函数能返回模型中求解的情况

- `@status()` ： 返回 LINGO 求解模型结束后的状态：是否可行，全局/局部最优
- `@dual(variable_name)` ： 返回变量的判别数的影子值

#### 随机数函数

`@rand(seed)` ： 返回 $0$ 和 $1$ 间的伪随机数，依赖于指定的种子。

> 一下子记忆太多内容是痛苦的，这些函数留到需要使用时再查阅具体资料即可（但是知道它们的存在倒是一件重要的事）
> 
> 概率函数和金融函数不包含在以上函数中，读者可以在需要使用时自行检索。

## LINGO 模型描述

我们直接用两个具体的例子来讲解 `LINGO` 的模型描述法如何处理规划类问题

### 例题 $1$

#### 题目描述

<center><img src = images/2.png width = 60%></center>

#### 题目代码和注释

```
model: ! 模型应写在 model 和 end 间的框架中 ;

sets: ! 集合数据类型定义 ;

! 定义 6 个仓库以及它们的容量属性 ;
warehouse/w1..w6/: capacity; 

! 定义 8 个客户以及他们的订单量属性 ;
client/c1..c8/: requirements; 

! 派生上面集合，links 集合的元素是上面两个集合的两两组合，这些元素有一个属性 freight ，相当于 freight(i, j) 为从仓库 i 运输给客户 j 所需要的运费 ;
! 同理 plan(i, j) 表示我们计划从仓库 i 运输给客户 j 的货运量，它就是本题的决策变量;
links(warehouse, client): freight, plan;

endsets

data: ! 集合数据类型赋值 ;

capacity = 60, 55, 51, 43, 41, 52;
requirements = 35, 37, 22, 32, 41, 32, 43, 38;
freight = 6, 2, 6, 7, 4, 2, 5, 9
          4, 9, 5, 3, 8, 5, 8, 2
          5, 2, 1, 9, 7, 4, 3, 3
          7, 6, 7, 3, 9, 2, 7, 1
          2, 3, 9, 5, 7, 2, 6, 5
          5, 5, 2, 2, 8, 1, 4, 3;
enddata

! 目标函数是求解总运费的最小值 ;
min = @sum(links(i, j) : freight(i, j) * x(i, j)); 

! 约束条件1：一个仓库运出的最大货物不应该超过仓库中的所有货物;
@for(warehouse(i) : @sum(client(j) : plan(i, j)) <= capacity(i));

! 约束条件2：应该刚好满足客户的订单量;
@for(client(j) : @sum(warehouse(i) : plan(i, j)) = requirement(j));

end
```

### 例题 $2$

#### 题目描述

旅行商问题（$TSP\ Problem$）

假设有 $9$ 个城市，它们之间两两距离为：

<center><img src = images/4.png width = 70%></center>

现在我们需要为旅行商设计一条路线，使得他可以经过所有的 $9$ 个城市（每个城市只经过一次），并且最终行走的总距离最少。

#### 代码和注释

```lingo

model:

sets:

! 定义一段路的起始城市和终点城市 ;
cities/city1..city9/: city;

! 定义两两城市之间的距离和路线 ;
! dist(i, j) 表示城市 i 和 j;
! route(i, j) = 1 表示环路中存在从城市 i 前往城市 j 这条路径，0 表示不存在 ;
links(cities, cities): dist, route;

endsets

data:

! 数据主要是需要传入两两城市之间的距离 ;
dist = 0, 200, 660, 170, 127, 225, 490, 420, 330                            
       200, 0, 820, 300, 90, 60, 310, 225, 151                        
       660, 820, 0, 530, 770, 120, 1110, 1050, 960                    
       170, 300, 530, 0, 280, 350, 600, 550, 450                
       127, 90, 770, 280, 0, 110, 370, 310, 210            
       225, 60, 120, 350, 110, 0, 280, 250, 120        
       490, 310, 1110, 600, 370, 280, 0, 290, 190    
       420, 225, 1050, 550, 310, 250, 290, 0, 160
       330, 151, 960, 450, 210, 120, 190, 160, 0 ;

enddata

n = @size(cities);

! 目标函数：求总路径的最小值 ;
! 只有在 route(i, j) 不为 0 时表示这条路径存在，乘以 dist(i, j) 代表计入相应的路径长度 ;
min = @sum(links(i, j) : dist(i, j) * route(i, j));

! 变量定界：0-1 规划问题 ;
@for(links(i, j) : @bin(route(i, j)));

! 每个城市必须到过一次，即路线矩阵: 
    - 每一行的和为 1 
    - 每一列的和也为 1 ;

! 每一行的和为 1 ;
@for(cities(j) : @sum(cities(i) : route(i,j)) = 1); ! 这里的 cities 就是一个“工具人” ，我们操作的属性并不属于这个集合，只是用它来提供索引 ;

! 每一列的和为 1 ;
@for(cities(i) : @sum(cities(j) : route(i,j)) = 1);

! 确保没有子圈（city(i) 和 city(j) 实际上没有赋值，并不具有真实涵义，用来当作辅助值） ;
@for(links(i, j) | i #ne# j #and# i #gt# 1 : city(i) - city(j) + n * route(i, j) <= n - 1);

end
```

## 写在后面

`LINGO` 一直以来就以内置建模语言和优秀的建模算法著称，不少人将 `LINGO` 作为优化模型求解的不二选择，但是 `LINGO` 真的就能解决所有的优化问题吗？

很显然答案是否定的—— `LINGO` 的优势在于求解非线性规划时比较方便，只需要使用编程语言描述模型，系统就能自动地给出解。这使得使用者不必关心 `LINDO` 公司具体选择了什么算法来执行求解的过程，能将更多的心力放在模型的架构和完善上。

但是假如我们要训练一个参数规模巨大的神经网络，使用 `LINGO` 来进行参数优化求解往往就显得心有余而力不足——因为过程中消耗的时间是我们不得不考虑的因素，这时我们就应该去考虑执行效率更高的工具。

> 同理对于 `matlab` 中提供的 `ga` 函数，

学会扬长避短，根据具体情况选择合适的工具也是建模能力之一。


> 参考资料：
> 
> 数据输入部分：https://zhuanlan.zhihu.com/p/153127289
>
> 数学函数部分：https://www.jianshu.com/p/a39b411ec367
>
> `LINGO` 建模例题：https://blog.csdn.net/Dai_sir_man/article/details/120064306 和 https://blog.csdn.net/Xiao_CangTian/article/details/89506978
>
> 其余部分：《`LINGO` 官方文档》

