# 从马尔可夫链到 Page Rank 算法

## （一）背景介绍

搜索技术的发展大致可以分为四个阶段，分类目录时期、文本检索时期、链接分析时期和以用户为中心的时期。链接分析时期的搜索引擎建立在文本检索的基础上，通过深入地分析网页中链接所隐含的信息，获取网页之间的“推荐关系”，通过对于链接地分析能够为用户推荐相关地网页，并进行精准地排名，极大改善了搜索质量和搜索体验。本文介绍的 $Page \ Rank$ 算法就是链接搜索领域的一个重要技术。

<center><img src = images/0.png width = 50%></center>

---

## （二）知识基础

### 随机游走模型

给定一个含有 $n$ 个结点的有向图，在有向图上定义随机游走（$Random\ Walk$）模型：

图的每个节点结点表示一个特定的状态，有向边则用来表示状态之间的转移，假设从一个结点到通过有向边相连的所有结点的转移概率相等。

假设状态从图的节点 $i$ 转移到节点 $j$ 的概率为 $m_{ij}$ ，将 $m_{ij}$ 作为一个矩阵的第 $i$ 行第 $j$ 列上的元素，那么就能构成一个大小为 （节点个数 $\times$ 节点个数）的矩阵，它被我们定义称转移矩阵 $M$

设转移矩阵 $M$ 的节点个数是 $n$ 。事实上，根据概率基本事实即可知以下结论总是成立：

$$
    m_{1j}+m_{2_j}+m_{3j}+\cdots+m_{nj}=\sum_{i=1}^nm_{ij}=1, \; j=1,2,\cdots,n
$$

这个模型就被称为随机游走模型，随机游走模型是马尔可夫链的基础。

### 马尔可夫链

#### 马尔可夫链概念介绍

马尔可夫链是一种假设某一状态转移的概率只依赖于它的前一个状态的模型。用数学语言可以表达为：

$$
    P(X^{t+1}|X^0,X^1,X^2,\cdots,X^t) = P(X^{t+1}|X^t)
$$

其中 $X^k$ 表示经过 $k$ 次状态转移后的当前状态，上述公式描述的是：当前状态仅和上一个状态有关，和上一个状态前的任意一个状态都无关。

概括而言，马尔可夫链应该具有核心三要素

- 状态空间（$State\ Space$）：状态能且只能在若干个状态间进行转换

- 无记忆性（$Memorylessness$）：当期选择的概率只受到上期状态的影响

- 转移矩阵（$Transition\ Matrix$）： 我们可以使用一个矩阵来描述一个状态转移到所有状态（包括自身状态）的概率，如果不存在转移到某状态的路径，则直接用 $0$ 表示其概率。  
    > 有向图的表示方法有邻接矩阵和邻接表，而实际上这里的转移矩阵的实质是一种带权的邻接矩阵

### 马尔可夫链的稳态

符合上述要求的马尔可夫链都会达到一个最终稳定的状态，如果我们将初始状态整合为一个状态向量，那么，每次得到的下一个状态向量的各状态概率可以用下式表示：

$$
\begin{pmatrix}
X_1^i\\
X_2^i\\
\vdots\\
X_n^i
\end{pmatrix}
=
\begin{pmatrix}
p_{11}&p_{12}&\cdots&p_{1n}\\
p_{21}&p_{22}&\cdots&p_{2n}\\
\vdots&\vdots&\ddots&\vdots\\
p_{n1}&p_{n2}&\cdots&p_{nn}    
\end{pmatrix}^i
\begin{pmatrix}
X_1^0\\
X_2^0\\
\vdots\\
X_n^0
\end{pmatrix}
$$

其中 $X_j^i$ 表示第 $j$ 个状态经过 $i$ 次迭代后得到的状态， $P_{ab}$ 表示第 $a$ 个状态转移到第 $b$ 个状态的概率。

我们可以通过一个简单的例子描述这样的模型：

小离每天选择饮料时总是进行两种选择：$A$ 或 $B$ ，在选择 $A$ 后依旧选择 $A$ 的概率为 $40\%$ ，在选择 $A$ 后选择 $B$ 的概率为 $60\%$ ，在选择 $B$ 后依旧选择 $B$ 的概率为 $50\%$，在选择 $B$ 后选择 $A$ 的概率为 $50\%$。这样我们统计小离每天的饮料选择状态，会发现小离每天的饮料选择倾向于 $B$，并且概率为 $54.5455\%$ ，趋近于某种稳态。

<center><img src = images/1.png width = 50%></center>

<center><img src = images/2.png width = 50%></center>

### 马尔可夫链的数学性质

除此之外，对于马尔可夫链，我们还可以发现这样的数学性质：如果我们经过足够多次的转移矩阵 $M$ 迭代，得到的稳态矩阵为 $R$ ，那么实际上由以下两式可知 $R$ 是转移矩阵的特征向量。

$$
RM = R\\

R(M-I)=O
$$

> 在这里我们当然可以借助高等代数的知识进行长篇大论的推演（应该会非常有趣），可是如何借助这个模型来实现一些服务于现实世界的程序，才是本文的重点部分。

---

## （三）Page Rank 算法

### Page Rank 的基本定义

由上面对于马尔可夫链的讨论可知，对于含有 $n$ 个节点的满足马尔可夫性质的有向图，我们在图上定义一个随机游走模型。

对于随机游走模型而言，从图上一个节点转移到与该节点连通的任何一个节点的概率相等。

> 你可能有点疑惑为什么就认为 “从图上一个节点转移到与该节点连通的任何一个节点的概率相等”。这实际上是一个默认的设定，我们也可以基于显示因素定量或定性地修正这些概率的值

而在 $Page Rank$ 模型中，我们设定每个节点都代表一个网页，节点之间的有向边就代表网页之间的链接关系：这样，网页群就被我们抽象成一张有向图。

根据这样的结果，我们不难直接定义出转移矩阵 $M$ ，可以证明，这种情况下，马尔可夫链也是具有最终平稳分布 $R$ 的。这样，只要得到最后的平稳分布，并且将平稳分布进行模长化（满足概率和为 $1$ 的分布要求），我们规定 $p(v_i)$ 为最终稳态分布中节点为 $v_i$ 的网页的“被访问概率”

$$
RM=R\ ;
\qquad
R=\begin{pmatrix}
p(v_1)\\
p(v_2)\\
\vdots\\
p(v_n)
\end{pmatrix}
\ ;
\qquad
\sum_{i=1}^np(v_i)=1
\ ;
$$

这是Page Rank中的基础模型，现实场景下，为了模拟复杂的情况，我们还需要对Page Rank模型进一步修正。

### Page Rank 算法模型

为更加清晰地解释下文的内容，我们利用一个简单的网站链接模型作为例子。

如图，有五个网站，它们之间的链接关系如图所示

<center><img src = images/3.png width = 32%></center>

我们定义一个转移矩阵来描述网页之间的链接关系和概率

$$

\begin{pmatrix}
1&\frac{1}{3}&0&0&0\\
0&0&\frac{1}{2}&0&0\\
0&\frac{1}{3}&0&1&1\\
0&\frac{1}{3}&\frac{1}{2}&0&0\\
0&0&0&0&0    
\end{pmatrix}

$$

> 再强调一下：这个矩阵的第 $i$ 行第 $j$ 列元素表示从网页 $i$ 转移到网页 $j$ 的概率

#### 规避转移到一个网站后无法继续转移的情况

如果进入到一个网站中，该网站不具有到任何其它网站的链接，那么一旦陷入这样的状态就会被当前页面局限而不再发生转移，这显然不是我们希望的状态。

这种情况在转换矩阵中体现为：一列中只有对角线元素为 $1$ 而其它元素为 $0$ 。

因此我们可以将这种不具备链接的网站近似成具备到所有其它网站的等效链接，即对矩阵的相关维的分量进行修正。

如假设一个页面转移矩阵的第一维分量为 $(1\quad0\quad0)$ ，则可以修正为 $(0.33\quad0.33\quad0.33)$ 。

同理，我们刚刚定义的转换矩阵应该修改为：

$$

\begin{pmatrix}
\frac{1}{5}&\frac{1}{3}&0&0&0\\
\frac{1}{5}&0&\frac{1}{2}&0&0\\
\frac{1}{5}&\frac{1}{3}&0&1&1\\
\frac{1}{5}&\frac{1}{3}&\frac{1}{2}&0&0\\
\frac{1}{5}&0&0&0&0    
\end{pmatrix}

$$

#### 阻尼系数的引入

用户在点击进入网站时，除了使用通过链接到达其它相关的网站，还有另一种选择——就是直接通过引擎转到当前网页未链接的网站，这种情况在我们之前的模型中是一直缺乏考虑的。

我们引入一个“阻尼系数” $d$ ，将它定义为用户通过链接跳转的概率，那么 $1-d$ 就是用户直接通过搜索引擎跳转的概率，我们规定用户通过非链接方式前往各个网站的概率相等，那么新的转换矩阵 $S$ 应该满足下面的公式

$$
S = dM+(1-d)\frac{K}{n}
$$

其中，$K$ 表示形状为（网页数$\times$网页数）且每个元素都是 $1$ 的矩阵。Google 的工程师统计得到 $d$ 取 $0.85$ 时效果最优。

下面展示了添加阻尼系数后的可视化数据：

<center><img src = images/4.png width = 50%></center>

---

## （四）Python 代码和 MATLAB 代码

提供了两个版本的 $Page\ Rank$ 代码

### MATLAB 版本

```m
function outrank = pagerank(n, times, tran_mat)
    % n 是网页的个数
    % times 表示迭代次数，次数越大，精度越高
    % tran_mat 表示转移矩阵
    
    %% 设置阻尼
    d = 0.85;
    bias = ones(n, n);
    for i = 1 : n
        for j = 1 : n
            tran_mat = d * tran_mat + (1 - d) * bias / n;
        end
    end

    %% 矩阵乘法

    value = zeros(n, times);
   
    for i = 1 : n
        value(i,1) = 1 / n;
    end

    for i = 2 : times + 1
       value(:, i) = tran_mat * value(:, i - 1); 
    end
    
    %% 作图
    curtime = 0 : 1 : times;
    colorGap = fix(255/n);
    for i = 1 : n
        plot(curtime,value(i, :),'-','Color', [i*colorGap/255, 127/255, (255 - i*colorGap)/255]);
        hold on;
    end
    xlabel("迭代次数");
    ylabel("状态值");
    legend("page1","page2","page3","page4","page5");

    %% 归一化并返回最终结果
    outrank = zeros(n);
    for i = 1 : n
        outrank(i) = value(i, times + 1)/sum(value(:,times + 1));
    end
end
```

### Python 版本

```python
import math
import random
import math
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

sns.set_style('darkgrid')

# 假设有A，B，C，D，E五个网站
n = 5
transfer_matrix = np.array(
    [[0.2, 0.2, 0.2, 0.2, 0.2], [0.333, 0, 0.333, 0.333, 0], [0, 0.5, 0, 0.5, 0], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0]], dtype='float32')
start_matrix = np.array([[1, 0, 0, 0, 0]], dtype='float32')  # 从A页面开始浏览

# 设置阻尼系数并利用阻尼系数对转换矩阵进行修正
d = 0.85
for i in range(n):
    for j in range(n):
        transfer_matrix[i][j] *= d
        transfer_matrix[i][j] += (1 - d) * (1 / n)

value1 = []
value2 = []
value3 = []
value4 = []
value5 = []

for i in range(30):
    start_matrix = np.dot(start_matrix, transfer_matrix)
    value1.append(start_matrix[0][0])
    value2.append(start_matrix[0][1])
    value3.append(start_matrix[0][2])
    value4.append(start_matrix[0][3])
    value5.append(start_matrix[0][4])

# 进行可视化
x = np.arange(30)

plt.plot(x, value1, label='Apage')
plt.plot(x, value2, label='Bpage')
plt.plot(x, value3, label='Cpage')
plt.plot(x, value4, label='Dpage')
plt.plot(x, value5, label='Epage')
plt.legend()
plt.show()
```
---

## （五）一点补充

我们稍微回顾一下最开头提出的马尔可夫链模型成立的三个条件

- 状态空间（$State\ Space$）：状态能且只能在若干个状态间进行转换

- 无记忆性（$Memorylessness$）：当期选择的概率只受到上期状态的影响

- 转移矩阵（$Transition\ Matrix$）： 我们可以使用一个矩阵来描述一个状态转移到所有状态（包括自身状态）的概率，如果不存在转移到某状态的路径，则直接用 $0$ 表示其概率。  

稍加辨析我们很容易发现现实生活中的网页链接模型事实上并不完全符合马尔科夫链的模型要求：

状态空间上，网页只能在若干网页之间进行链接跳转事实上并不完全符合现实生活中的情况，用户随时有可能做出我们规定了网页群外的其他网页选择。并且还有一些极端情况：某些网页甚至没有跳转到其他网页的链接。

无记忆性上，用户的若干连续网页跳转之间可能满足一定的逻辑规律，认为当期选择的概率只受上期状态的影响似乎也不完全符合现实。

转移矩阵上，我们似乎会发现一个不变的矩阵很难满足我们当前的需求：用户在浏览的过程中很有可能对他们的转移矩阵做出一定的更新。

然而，当我们考虑所有这些复杂的现实因素时，我们会发现建模成为了一件似乎不可能的事，拟和现实生活中的一切因素听起来很酷，却会使我们的建模成为一件混乱而复杂的事，不妨看看 $Page\ Rank$ 模型是怎么处理这些问题的：

- 忽略网页群外的其他网页选择，将状态空间严格控制在一定的范围内，对于无法跳转到其他网页的链接，直接默认为拥有跳转到所有网页群内的网页的链接。
  
- 忽略用户连续网页跳转之间的规律，认为用户上一次浏览的网页对于接下来要浏览哪个网页而言具有绝对权重。

- 忽略用户在浏览过程中的一些情况导致的转移矩阵更新，因为不恒定的转移矩阵很有可能使马尔科夫链无法得到一个收敛的结果。

因此，建模既是对现实世界的拟合，也是对现实世界的忽略——抽象必然伴随着忽略。事实也证明，先通过忽略的方式得到抽象的模型，然后在这基础上不断对模型进行基于现实的修正和更改，才是最佳的建模方法。
